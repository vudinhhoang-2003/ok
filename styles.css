import java.io.IOException;
import java.util.Iterator;
import java.util.StringTokenizer;

import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapred.JobConf;
import org.apache.hadoop.mapred.JobClient;
import org.apache.hadoop.mapred.Mapper;
import org.apache.hadoop.mapred.MapReduceBase;
import org.apache.hadoop.mapred.Reducer;
import org.apache.hadoop.mapred.Reporter;
import org.apache.hadoop.mapred.OutputCollector;
import org.apache.hadoop.mapred.FileInputFormat;
import org.apache.hadoop.mapred.FileOutputFormat;

public class ProcessUnits {

    // Mapper class
    public static class E_Mapper extends MapReduceBase implements Mapper<LongWritable, Text, Text, IntWritable> {
        // Map function
        public void map(LongWritable key, Text value, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {
            String line = value.toString();
            String lasttoken = null;
            StringTokenizer s = new StringTokenizer(line, "\t");
            String year = s.nextToken();

            while (s.hasMoreTokens()) {
                lasttoken = s.nextToken();
            }

            int avgprice = Integer.parseInt(lasttoken);
            output.collect(new Text(year), new IntWritable(avgprice));
        }
    }

    // Reducer class
    public static class E_Reduce extends MapReduceBase implements Reducer<Text, IntWritable, Text, IntWritable> {
        // Reduce function
        public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException {
            int maxavg = 30;
            int val = Integer.MIN_VALUE;

            while (values.hasNext()) {
                if ((val = values.next().get()) > maxavg) {
                    output.collect(key, new IntWritable(val));
                }
            }
        }
    }

    // Main function
    public static void main(String args[]) throws Exception {
        JobConf conf = new JobConf(ProcessUnits.class);
        conf.setJobName("max_electricityunits");

        conf.setOutputKeyClass(Text.class);
        conf.setOutputValueClass(IntWritable.class);

        conf.setMapperClass(E_Mapper.class);
        conf.setCombinerClass(E_Reduce.class);
        conf.setReducerClass(E_Reduce.class);

        conf.setInputFormat(org.apache.hadoop.mapred.TextInputFormat.class);
        conf.setOutputFormat(org.apache.hadoop.mapred.TextOutputFormat.class);

        FileInputFormat.setInputPaths(conf, new Path(args[0]));
        FileOutputFormat.setOutputPath(conf, new Path(args[1]));

        JobClient.runJob(conf);
    }
}











    CREATE TABLE IF NOT EXISTS retail_sales_data (
    year INT,
    month INT,
    supplier STRING,
    item_code STRING,
    item_description STRING,
    item_type STRING,
    retail_sales DOUBLE,
    retail_transfers DOUBLE,
    warehouse_sales DOUBLE
)
ROW FORMAT DELIMITED 
FIELDS TERMINATED BY ',' 
STORED AS TEXTFILE
TBLPROPERTIES ("skip.header.line.count"="1");







    1. Tính tổng doanh số bán lẻ và doanh số kho theo từng nhà cung cấp
sql
Copy code
SELECT 
    supplier,
    SUM(retail_sales) AS total_retail_sales,
    SUM(warehouse_sales) AS total_warehouse_sales
FROM 
    retail_sales_data
GROUP BY 
    supplier
ORDER BY 
    total_retail_sales DESC, total_warehouse_sales DESC;
Giải thích:
SUM: Tính tổng doanh số bán lẻ (retail_sales) và doanh số kho (warehouse_sales) cho từng nhà cung cấp (supplier).
GROUP BY supplier: Dữ liệu được nhóm theo từng nhà cung cấp.
ORDER BY: Sắp xếp kết quả theo tổng doanh số bán lẻ giảm dần, sau đó là tổng doanh số kho.
Mục đích:
Xác định nhà cung cấp nào có doanh số cao nhất để tối ưu hợp tác.





    5. Phân tích sự thay đổi doanh số bán lẻ theo từng năm và loại sản phẩm
sql
Copy code
SELECT 
    year,
    item_type,
    SUM(retail_sales) AS total_retail_sales,
    SUM(warehouse_sales) AS total_warehouse_sales,
    SUM(retail_transfers) AS total_retail_transfers
FROM 
    retail_sales_data
GROUP BY 
    year, item_type
ORDER BY 
    year ASC, total_retail_sales DESC;
Giải thích:
GROUP BY year, item_type: Dữ liệu được nhóm theo năm và loại sản phẩm.
SUM: Tính tổng doanh số bán lẻ, kho và chuyển kho.
ORDER BY year ASC, total_retail_sales DESC: Sắp xếp theo năm (tăng dần), sau đó theo doanh số bán lẻ (giảm dần).
Mục đích:
Phân tích xu hướng thay đổi doanh số của từng loại sản phẩm qua các năm để đưa ra quyết định chiến lược dài hạn.
